import asyncio
import importlib.util
import os
import re
import sys
from pathlib import Path

from mcp.server.fastmcp import FastMCP
from pydantic import Field

from apex_arena.prompts import (
    get_problem_image_prompts,
    get_problem_metadata,
    load_problem_prompt,
)
from apex_arena.utils import Grade, Prompts

BASE_DIR = os.environ.get("BASE_DIR", "/mcp_server")

mcp = FastMCP("apex-arena", host="0.0.0.0", port=8001)
TEST_MODE = os.environ.get("MCP_TESTING_MODE", "0") in ["1", "true"]

if TEST_MODE:
    from apex_arena.tools import BashTool, Command, EditTool

    bash_tool = BashTool()

    @mcp.tool()
    async def bash(
        command: str = Field(description="The bash command to execute"),
        restart: bool = Field(
            default=False,
            description="Set to true to restart the bash session. Required when you see an error message saying 'must be restarted'."
        )
    ):
        """Execute bash commands in a persistent session. If the bash session times out or crashes, you must call this tool with restart=true before running new commands."""
        return await bash_tool(command, restart)

    from apex_arena.tools_cu import ComputerTool
    computer_tool = ComputerTool()
    @mcp.tool()
    async def computer(
        *,
        action: str,
        text: str | None = None,
        coordinate: tuple[int, int] | None = None,
        start_coordinate: tuple[int, int] | None = None,
        duration: int | float | None = None,
        scroll_direction: str | None = None,
        scroll_amount: int | None = None,
    ):
        return await computer_tool(
            action=action,
            text=text,
            coordinate=coordinate,
            start_coordinate=start_coordinate,
            duration=duration,
            scroll_direction=scroll_direction,
            scroll_amount=scroll_amount,
        )

    edit_tool = EditTool()

    @mcp.tool(
        name="str_replace_editor",
        description="Create and edit files using str_replace_editor. Please do not use this tool to delete or clear files and use bash instead. Please use absolute paths for all file names.  When writing files please work within /workdir.",
    )
    async def str_replace_editor(
        *,
        command: Command,
        path: str,
        file_text: str | None = None,
        view_range: list[int] | None = None,
        old_str: str | None = None,
        new_str: str | None = None,
        insert_line: int | None = None,
    ):
        return await edit_tool(
            command=command,
            path=path,
            file_text=file_text,
            view_range=view_range,
            old_str=old_str,
            new_str=new_str,
            insert_line=insert_line,
        )


current_problem = None
current_grader = None
current_grader_timeout = 600  # Default grader timeout in seconds
last_grader = Grade(
    subscores={"initial": 0.0},
    weights={"initial": 1.0},
    metadata={"feedback": "Agent call failed!"},
)


@mcp.tool()
async def setup_problem(
    problem_id: str = Field(description="The ID of the problem to set up"),
) -> Prompts:
    global current_problem, current_grader, current_grader_timeout, bash_tool

    prompt = load_problem_prompt(problem_id)
    metadata = get_problem_metadata(problem_id)
    image_prompts = get_problem_image_prompts(problem_id)

    # Configure bash tool timeout from metadata
    # agent_max_timeout is the max timeout for bash tool (capped at 600 seconds / 10 minutes)
    if TEST_MODE:
        agent_timeout = metadata.get('agent_max_timeout', 600)
        # Cap at 600 seconds (10 minutes) as requested
        agent_timeout = min(agent_timeout, 600)
        bash_tool = BashTool(timeout=agent_timeout)

    # Configure grader timeout from metadata
    # grader_max_timeout is the max timeout for grade_problem tool (capped at 600 seconds / 10 minutes)
    grader_timeout = metadata.get('grader_max_timeout', 600)
    current_grader_timeout = min(grader_timeout, 600)

    grader_path = Path(BASE_DIR) / "tasks" / problem_id / "grader.py"
    if not grader_path.exists():
        raise ValueError(f"Grader not found for problem {problem_id}")

    spec = importlib.util.spec_from_file_location("grader", grader_path)
    grader_module = importlib.util.module_from_spec(spec)
    sys.modules["grader"] = grader_module
    spec.loader.exec_module(grader_module)

    setup_script = Path(BASE_DIR) / "tasks" / problem_id / "setup.sh"
    if setup_script.exists():
        import subprocess

        result = subprocess.run(
            ["bash", "-e", str(setup_script)],
            capture_output=True,
            text=True,
        )
        if result.returncode != 0:
            error_msg = f"setup.sh failed with exit code {result.returncode}"
            if result.stdout:
                error_msg += f"\nstdout:\n{result.stdout}"
            if result.stderr:
                error_msg += f"\nstderr:\n{result.stderr}"
            raise RuntimeError(error_msg)

    current_problem = problem_id
    current_grader = grader_module

    return Prompts(prompt=prompt, image_prompts=image_prompts)


@mcp.tool()
async def grade_problem(
    problem_id: str,
    transcript: str = Field(
        description="The entire transcript produced by the model and its tool calls"
    ),
) -> Grade:
    global current_problem, current_grader, current_grader_timeout

    if not current_problem or not current_grader:
        raise ValueError("No problem is currently set up")

    try:
        matches = re.findall(r"<answer>(.*?)</answer>", transcript, re.DOTALL)
        if matches:
            solution = matches[-1]
        else:
            solution = transcript
    except Exception as e:
        return Grade(
            subscores={"solution_found": 0.0},
            weights={"solution_found": 1.0},
            metadata={
                "feedback": f"Error extracting solution from answer tags: {str(e)}"
            },
        )

    # Run grader with timeout (grader_max_timeout from task metadata)
    try:
        async with asyncio.timeout(current_grader_timeout):
            # Run grader in executor since it's synchronous
            loop = asyncio.get_event_loop()
            result = await loop.run_in_executor(None, current_grader.grade, solution)
            return Grade(
                subscores=result.subscores,
                weights=result.weights,
                metadata={"feedback": result.feedback},
            )
    except asyncio.TimeoutError:
        return Grade(
            subscores={"grading": 0.0},
            weights={"grading": 1.0},
            metadata={
                "feedback": f"Grading timed out after {current_grader_timeout} seconds"
            },
        )


def main():
    os.chdir("/workdir")
    if TEST_MODE:
        mcp.run(transport="streamable-http")
    else:
        mcp.run(transport="stdio")


if __name__ == "__main__":
    main()
