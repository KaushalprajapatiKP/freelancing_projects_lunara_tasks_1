import os
import uuid
import zipfile
from pathlib import Path
from typing import Any, Dict, List, Optional

from rich.console import Console

console = Console()


def get_tasks_dir() -> Path:
    """Get the tasks directory from environment variable or default."""
    tasks_dir_str = os.getenv("APEX_TASK_DIR", "tasks")
    return Path(tasks_dir_str).resolve()


def is_valid_uuid(value: str) -> bool:
    """Check if a string is a valid UUID."""
    try:
        uuid.UUID(value)
        return True
    except ValueError:
        return False


def get_local_task_version(task_id: str, tasks_dir: Path = None) -> Optional[int]:
    """Get the version number of a locally cached task."""
    if tasks_dir is None:
        tasks_dir = get_tasks_dir()

    metadata_file = tasks_dir / task_id / ".apex_metadata.json"
    if not metadata_file.exists():
        return None

    try:
        import json

        with open(metadata_file, "r") as f:
            metadata = json.load(f)
            version_info = metadata.get("version_info", {})
            return version_info.get("version_number")
    except Exception:
        return None


def is_local_task(task_id: str, tasks_dir: Path = None, task_format: str = "auto") -> bool:
    """Check if task_id exists as a local task directory.

    Args:
        task_id: The task identifier to check
        tasks_dir: Path to tasks directory (defaults to APEX_TASK_DIR or ./tasks)
        task_format: Task format to check for ("apex", "harbor", or "auto" to try all)

    Returns:
        True if the task exists locally in the specified format (or any format if "auto")
    """
    if tasks_dir is None:
        tasks_dir = get_tasks_dir()

    task_dir = tasks_dir / task_id
    if not task_dir.exists() or not task_dir.is_dir():
        return False

    # Use format adapter to check if task is valid
    from .task_formats import FormatRegistry

    if task_format == "auto":
        # Try all registered formats
        for fmt in FormatRegistry.list_formats():
            try:
                adapter = FormatRegistry.get_adapter(fmt)
                if adapter.is_valid_task(task_dir):
                    return True
            except ValueError:
                continue
        return False

    try:
        adapter = FormatRegistry.get_adapter(task_format)
        return adapter.is_valid_task(task_dir)
    except ValueError:
        # Unknown format, fall back to trying all formats
        for fmt in FormatRegistry.list_formats():
            try:
                adapter = FormatRegistry.get_adapter(fmt)
                if adapter.is_valid_task(task_dir):
                    return True
            except ValueError:
                continue
        return False


def is_remote_task(task_id: str) -> bool:
    """Check if task_id exists as a remote task by making API call."""
    # Only UUIDs can be remote tasks
    if not is_valid_uuid(task_id):
        return False

    try:
        from .api_client import get_api_client

        api_client = get_api_client()

        # Try to get task info - if it exists, this will succeed
        api_client.get_task(task_id)
        return True
    except Exception:
        # If any error occurs (not found, auth, network), treat as not found
        return False


def download_remote_task(task_id: str, tasks_dir: Path = None) -> Dict[str, Any]:
    """
    Download remote task to tasks directory.
    Returns dict with local task directory name and version info.
    """
    if tasks_dir is None:
        tasks_dir = get_tasks_dir()

    # Ensure tasks directory exists
    tasks_dir.mkdir(exist_ok=True)

    local_dir = tasks_dir / task_id

    # Check if already downloaded and if we need to update
    if is_local_task(task_id, tasks_dir):
        try:
            from .api_client import get_api_client

            api_client = get_api_client()

            # Get remote version to check if we need to update
            console.print(
                f"[dim]Task {task_id} exists locally, checking for updates...[/dim]"
            )
            remote_version_info = api_client.get_task_version(task_id)
            remote_version = remote_version_info["task_version_id"]
            local_version = get_local_task_version(task_id, tasks_dir)

            # Compare versions
            if remote_version is not None and local_version is not None:
                if remote_version > local_version:
                    console.print(
                        f"[yellow]Found newer {remote_version} (local: {local_version}), updating...[/yellow]"
                    )
                    # Continue to download new version (fall through to download logic)
                elif remote_version == local_version:
                    console.print(
                        f"[green]Local version {local_version} is up to date[/green]"
                    )
                    return {
                        "local_task_id": task_id,
                        "task_version_id": local_version,
                        "version_info": remote_version_info["version_info"],
                        "downloaded": False,
                    }
                else:
                    console.print(
                        f"[blue]Local version {local_version} is newer than remote {remote_version}[/blue]"
                    )
                    return {
                        "local_task_id": task_id,
                        "task_version_id": local_version,
                        "version_info": remote_version_info["version_info"],
                        "downloaded": False,
                    }
            else:
                # If we can't determine versions, re-download to be safe
                console.print(
                    "[yellow]Could not determine version info, re-downloading...[/yellow]"
                )

        except Exception as e:
            console.print(
                f"[yellow]Warning: Could not check remote version: {e}. Using local copy.[/yellow]"
            )
            # Fall back to using local version
            local_version = get_local_task_version(task_id, tasks_dir)
            return {
                "local_task_id": task_id,
                "task_version_id": local_version,
                "version_info": {},
                "downloaded": False,
            }

    try:
        from .api_client import get_api_client

        api_client = get_api_client()

        console.print(f"[yellow]Downloading task {task_id}...[/yellow]")

        # Download task with version info
        download_result = api_client.download_task(task_id)
        zip_content = download_result["zip_content"]
        task_version_id = download_result["task_version_id"]
        version_info = download_result["version_info"]

        # Extract ZIP to tasks directory
        extract_zip_to_tasks(zip_content, task_id, tasks_dir)

        # Store version metadata locally
        metadata_file = local_dir / ".apex_metadata.json"
        try:
            import json

            metadata = {
                "task_id": task_id,
                "version_info": version_info,
                "downloaded_at": __import__("datetime")
                .datetime.now(__import__("datetime").timezone.utc)
                .isoformat(),
            }
            with open(metadata_file, "w") as f:
                json.dump(metadata, f, indent=2)
        except Exception as e:
            console.print(
                f"[yellow]Warning: Failed to save version metadata: {e}[/yellow]"
            )

        if task_version_id:
            console.print(
                f"[green]✓ Task {task_id} (version {task_version_id}) downloaded successfully[/green]"
            )
        else:
            console.print(f"[green]✓ Task {task_id} downloaded successfully[/green]")

        return {
            "local_task_id": task_id,
            "task_version_id": task_version_id,
            "version_info": version_info,
            "downloaded": True,
        }

    except Exception as e:
        console.print(f"[red]Error downloading task {task_id}: {e}[/red]")
        # Clean up partially downloaded directory
        if local_dir.exists():
            import shutil

            shutil.rmtree(local_dir)
        raise


def extract_zip_to_tasks(zip_content: bytes, task_id: str, tasks_dir: Path) -> None:
    """Extract ZIP content to tasks/{task_id}/ directory."""
    import io

    local_dir = tasks_dir / task_id

    # Remove existing directory if it exists
    if local_dir.exists():
        import shutil

        shutil.rmtree(local_dir)

    # Create directory
    local_dir.mkdir(parents=True)

    # Extract ZIP
    with zipfile.ZipFile(io.BytesIO(zip_content), "r") as zip_file:
        zip_file.extractall(local_dir)

    console.print(
        f"[dim]Extracted {len(zip_file.namelist())} files to {local_dir}[/dim]"
    )


def resolve_tasks(task_id_list: List[str], tasks_dir: Path = None, task_format: str = "auto") -> Dict[str, Any]:
    """
    Resolve task IDs to local task directories.
    Downloads remote tasks if needed.
    Returns dict with task list and version mapping.

    Args:
        task_id_list: List of task IDs (local task names or remote UUIDs)
        tasks_dir: Path to tasks directory (defaults to APEX_TASK_DIR env var or ./tasks)
        task_format: Task format to use ("auto", "apex", or "harbor")

    Returns:
        Dict containing:
        - tasks: List of validated local task directory names
        - task_versions: Dict mapping task_id -> task_version_id

    Raises:
        ValueError: If any task ID is invalid or cannot be resolved
    """
    if tasks_dir is None:
        tasks_dir = get_tasks_dir()

    resolved_tasks = []
    task_versions = {}
    updated_tasks = []
    errors = []

    # Process each task ID
    for task_id in task_id_list:
        task_id = task_id.strip()
        if not task_id:
            continue

        try:
            # Check if task exists locally first
            if is_local_task(task_id, tasks_dir, task_format):
                # For local tasks that are UUIDs, check for updates
                if is_valid_uuid(task_id):
                    try:
                        from .api_client import get_api_client

                        api_client = get_api_client()

                        # Get remote version to check if we need to update
                        console.print(
                            f"[dim]Task {task_id} exists locally, checking for updates...[/dim]"
                        )
                        remote_version_info = api_client.get_task_version(task_id)
                        remote_version = remote_version_info["task_version_id"]
                        local_version = get_local_task_version(task_id, tasks_dir)

                        # Compare versions
                        if remote_version is not None and local_version is not None:
                            if remote_version > local_version:
                                console.print(
                                    f"[yellow]Found newer {remote_version} (local: {local_version}), updating...[/yellow]"
                                )
                                # Download new version
                                download_result = download_remote_task(
                                    task_id, tasks_dir
                                )
                                resolved_tasks.append(download_result["local_task_id"])
                                if download_result["task_version_id"]:
                                    task_versions[task_id] = download_result[
                                        "task_version_id"
                                    ]
                                if download_result.get("downloaded", False):
                                    updated_tasks.append(task_id)
                                continue
                            elif remote_version == local_version:
                                console.print(
                                    f"[green]✓ Remote task (cached locally): {task_id} (version {local_version}) - up to date[/green]"
                                )
                                resolved_tasks.append(task_id)
                                task_versions[task_id] = local_version
                                continue
                            else:
                                console.print(
                                    f"[blue]✓ Remote task (cached locally): {task_id} (version {local_version}) - local newer than remote {remote_version}[/blue]"
                                )
                                resolved_tasks.append(task_id)
                                task_versions[task_id] = local_version
                                continue
                        else:
                            # If we can't determine versions, re-download to be safe
                            console.print(
                                "[yellow]Could not determine version info, re-downloading...[/yellow]"
                            )
                            download_result = download_remote_task(task_id, tasks_dir)
                            resolved_tasks.append(download_result["local_task_id"])
                            if download_result["task_version_id"]:
                                task_versions[task_id] = download_result[
                                    "task_version_id"
                                ]
                            if download_result.get("downloaded", False):
                                updated_tasks.append(task_id)
                            continue

                    except Exception as e:
                        console.print(
                            f"[yellow]Warning: Could not check remote version: {e}. Using local copy.[/yellow]"
                        )
                        # Fall back to using local version
                        local_version = get_local_task_version(task_id, tasks_dir)
                        resolved_tasks.append(task_id)
                        if local_version:
                            task_versions[task_id] = local_version
                        console.print(
                            f"[green]✓ Remote task (cached locally): {task_id}"
                            + (f" (version {local_version})" if local_version else "")
                            + "[/green]"
                        )
                        continue
                else:
                    # Local non-UUID task
                    resolved_tasks.append(task_id)
                    console.print(f"[green]✓[/green] Local task: {task_id}")
                    continue

            # Check if it's a valid remote task that needs downloading
            if is_remote_task(task_id):
                console.print(
                    f"[yellow]→[/yellow] Remote task (downloading): {task_id}"
                )
                download_result = download_remote_task(task_id, tasks_dir)
                local_name = download_result["local_task_id"]
                task_version_id = download_result["task_version_id"]

                resolved_tasks.append(local_name)
                if task_version_id:
                    task_versions[task_id] = task_version_id
                if download_result.get("downloaded", False):
                    updated_tasks.append(task_id)
                continue

            # Neither local nor remote
            if is_valid_uuid(task_id):
                errors.append(f"Remote task not found: {task_id}")
            else:
                errors.append(f"Local task not found: {task_id}")

        except Exception as e:
            errors.append(f"Error resolving {task_id}: {e}")

    # Report any errors
    if errors:
        console.print("[red]Task resolution errors:[/red]")
        for error in errors:
            console.print(f"[red]  • {error}[/red]")
        raise ValueError(f"Failed to resolve {len(errors)} task(s)")

    if not resolved_tasks:
        raise ValueError("No valid tasks provided")

    console.print(f"[green]Successfully resolved {len(resolved_tasks)} task(s)[/green]")
    if updated_tasks:
        console.print(f"[yellow]Updated {len(updated_tasks)} task(s): {', '.join(updated_tasks)}[/yellow]")
    return {
        "tasks": resolved_tasks,
        "task_versions": task_versions,
        "updated_tasks": updated_tasks
    }


def parse_task_ids(task_ids_str: str) -> List[str]:
    """Parse comma-separated task IDs string into list."""
    if not task_ids_str:
        return []

    return [task_id.strip() for task_id in task_ids_str.split(",") if task_id.strip()]
